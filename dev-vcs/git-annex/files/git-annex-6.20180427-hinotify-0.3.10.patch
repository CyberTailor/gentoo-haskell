--- git-annex-6.20180427-orig/Utility/DirWatcher/INotify.hs	2018-04-28 02:37:59.000000000 +1000
+++ git-annex-6.20180427/Utility/DirWatcher/INotify.hs	2018-05-01 19:28:11.252599554 +1000
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 {- higher-level inotify interface
  -
  - Copyright 2012 Joey Hess <id@joeyh.name>
@@ -16,6 +17,19 @@
 import System.IO.Error
 import Control.Exception (throw)
 
+#if MIN_VERSION_hinotify(0,3,10)
+import qualified Data.ByteString.Char8 as BS (ByteString, pack, unpack)
+unpack :: BS.ByteString -> String
+unpack = BS.unpack
+pack :: String -> BS.ByteString
+pack = BS.pack
+#else
+unpack :: String -> String
+unpack = id
+pack :: String -> String
+pack = id
+#endif
+
 {- Watches for changes to files in a directory, and all its subdirectories
  - that are not ignored, using inotify. This function returns after
  - its initial scan is complete, leaving a thread running. Callbacks are
@@ -55,7 +69,7 @@
 		lock <- newLock
 		let handler event = withLock lock (void $ go event)
 		flip catchNonAsync failedwatch $ do
-			void (addWatch i watchevents dir handler)
+			void (addWatch i watchevents (pack dir) handler)
 				`catchIO` failedaddwatch
 			withLock lock $
 				mapM_ scan =<< filter (not . dirCruft) <$>
@@ -94,40 +108,40 @@
 					noop
 
 	go (Created { isDirectory = isd, filePath = f })
-		| isd = recurse $ indir f
+		| isd = recurse $ indir (unpack f)
 		| otherwise = do
-			ms <- getstatus f
+			ms <- getstatus (unpack f)
 			case ms of
 				Just s
 					| Files.isSymbolicLink s -> 
 						when (hashook addSymlinkHook) $
-							runhook addSymlinkHook f ms
+							runhook addSymlinkHook (unpack f) ms
 					| Files.isRegularFile s ->
 						when (hashook addHook) $
-							runhook addHook f ms
+							runhook addHook (unpack f) ms
 				_ -> noop
 	-- Closing a file is assumed to mean it's done being written,
 	-- so a new add event is sent.
 	go (Closed { isDirectory = False, maybeFilePath = Just f }) =
-			checkfiletype Files.isRegularFile addHook f
+			checkfiletype Files.isRegularFile addHook (unpack f)
 	-- When a file or directory is moved in, scan it to add new
 	-- stuff.
-	go (MovedIn { filePath = f }) = scan f
+	go (MovedIn { filePath = f }) = scan (unpack f)
 	go (MovedOut { isDirectory = isd, filePath = f })
-		| isd = runhook delDirHook f Nothing
-		| otherwise = runhook delHook f Nothing
+		| isd = runhook delDirHook (unpack f) Nothing
+		| otherwise = runhook delHook (unpack f) Nothing
 	-- Verify that the deleted item really doesn't exist,
 	-- since there can be spurious deletion events for items
 	-- in a directory that has been moved out, but is still
 	-- being watched.
 	go (Deleted { isDirectory = isd, filePath = f })
-		| isd = guarded $ runhook delDirHook f Nothing
-		| otherwise = guarded $ runhook delHook f Nothing
+		| isd = guarded $ runhook delDirHook (unpack f) Nothing
+		| otherwise = guarded $ runhook delHook (unpack f) Nothing
 	  where
-		guarded = unlessM (filetype (const True) f)
+		guarded = unlessM (filetype (const True) (unpack f))
 	go (Modified { isDirectory = isd, maybeFilePath = Just f })
 		| isd = noop
-		| otherwise = runhook modifyHook f Nothing
+		| otherwise = runhook modifyHook (unpack f) Nothing
 	go _ = noop
 
 	hashook h = isJust $ h hooks
